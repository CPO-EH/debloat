import enum
import pefile
from pefile import Structure as Structure
from typing import Any, Callable, Optional, Tuple

PACKER: Any

class RSRC(enum.IntEnum):
    CURSOR: int
    BITMAP: int
    ICON: int
    MENU: int
    DIALOG: int
    STRING: int
    FONTDIR: int
    FONT: int
    ACCELERATOR: int
    RCDATA: int
    MESSAGETABLE: int
    ICON_GROUP: int
    VERSION: int
    DLGINCLUDE: int
    PLUGPLAY: int
    VXD: int
    ANICURSOR: int
    ANIICON: int
    HTML: int
    MANIFEST: int

def readable_size(value: int) -> str: ...
def write_patched_file(out_path: str, pe: pefile.PE, end_of_real_data: int) -> Tuple[int, str]: ...
def handle_signature_abnormality(signature_address: int, signature_size: int, beginning_file_size: int) -> bool: ...
def check_for_packer(pe: pefile.PE) -> int: ...
def find_last_section(pe: pefile.PE) -> Optional[pefile.SectionStructure]: ...
def get_signature_info(pe: pefile.PE) -> Tuple[int, int]: ...
def adjust_offsets(pe: pefile.PE, gap_offset: int, gap_size: int): ...
def refinery_strip(pe: pefile.PE, data: memoryview, block_size=...) -> int: ...
def refinery_trim_resources(pe: pefile.PE, pe_data: bytearray) -> int: ...
def remove_resources(pe: pefile.PE, pe_data: bytearray) -> Tuple[bytearray, int]: ...
def check_section_compression(pe: pefile.PE, pe_data: bytearray, end_of_real_data, log_message: Callable[[str], None]) -> Tuple[pefile.PE, int, str]: ...
def trim_junk(bloated_content: bytes, original_size_with_junk: int) -> int: ...
def process_pe(pe: pefile.PE, out_path: str, unsafe_processing: bool, log_message: Callable[[str], None]) -> None: ...
